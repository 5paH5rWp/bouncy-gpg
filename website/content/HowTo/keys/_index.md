{
"title" : "Key generation and derivation",
"description": "Cryptographic keys are the input parameters to many cryptographic operations, namely en-/decryption and signatures. This HOWTO will show you how to create keys from passwords, and how to derive multiple keys from one master key.",
"tags" : [
    "howto",
    "key derivation"
],
"categories" : [
    "keys"
]
}

Cryptographic keys are the input parameters to many cryptographic operations, namely en-/decryption and signatures. This HOWTO will show you how to create _symmetric_ keys from passwords, and how to derive multiple keys from one master key. The creation/derivation of _public/private keys_ is described in the GPG-sections.

## Key usage

Cryptographic algorithms have some, often not very obvious and seemingly arcane, pitfalls. A lot of these pitfalls regard the usage of cryptographic keys.

Without going too much into the details, here is a very important "law" that you should abide to until a cryptographer tells you otherwise:

**A cryptographic key should only be used to encrypt a single data item. Failure to do so can lead to catastrophic failures(TODO: Link to 'Double OTP')!**

If you already have a cryptographically strong key it can be used to _derive_ more keys from it. These keys are often called _data protection keys_ because they are used to protect a single data item.

Common pitfalls with the _single data item_ is:
* If you change a record (`UPDATE`), you must use a new key.
* Memory hook: _If you ever call `Chipher::init(Cipher.ENCRYPT_MODE, ..)`  with the same key you are probably doing it wrong._

Depending on the mode of operation a single key can only encrypt a specific amount of data (all values for AES):

| *Mode* |  *Max. encrypted data per key* | *Note*            | *Reference* |
|--------|--------------------------------|-------------------|-------------|
|  ~ECB~ |                                | Do not use        | [NIST Special Publication 800-38A: 6.1 ](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf)             |
|  CBC   |   TODO                         | TODO              | [NIST Special Publication 800-38A: ](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf)         |
|  GCM   |   26 GB (2^39-256 bits)        | AEAD              | [NIST Special Publication 800-38D: 5.2.1.1](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf)        |
|  CCM   |   2048 TB (2^64 bits)          | AEAD,Two-pass (slow)   | [NIST Special Publication 800-38C: A.1 ](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38c.pdf)       |

## Obtaining Keys

Cryptographic keys can be obtained by two methods:

* by generating a key from random data (e.g. `SecureRandom`)
* by deriving the key from other data (_input key material_)


### Key Generation

Cryptographic keys can be generated by using a [random number generator (RNG)](https://en.wikipedia.org/wiki/Random_number_generation). Cryptographic keys should always be generated by using a key derivation function ([KDF](kdf/)). The only exception is when a secure random number generator is used (e.g. `SecureRandom`).

Creating a key by using a secure random number generator:

{{<mermaid align="left">}}
graph LR;
    SRNG[fa:fa-cog Secure Random Number Generator] -->  K(fa:fa-key Key)
    K -.-> AES[fa:fa-cog AES]
    
    classDef dotted_border stroke-width:2,stroke-dasharray:2,4;
    class AES dotted_border
{{< /mermaid >}}


Deriving a key from key material (IKM - Input Key Material) provided by some other process, e.g. a [Diffieâ€“Hellman key exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange):
{{<mermaid align="left">}}
graph LR;
    SourceProcess[fa:fa-cog Some key agreement protocol] -.-> IKM(Input Key Material)
    IKM --> KDF[fa:fa-cog Key Derivation Function]
    KDF --> K(fa:fa-key Key)
    K -.-> AES[fa:fa-cog AES]
    
    classDef dotted_border stroke-width:2,stroke-dasharray:2,4;
    class SourceProcess,AES dotted_border
{{< /mermaid >}}


### Key Derivation

The words _password_ and _cryptographic key_ are often used interchangeably, although they are technically quite different.

A _password_ is a sequence of characters of often arbitrary length. A _cryptographic key_ is a binary object that has an algorithm specific structure to it.

Passwords can be transformed into keys by applying a [password based key derivation functions](passwords/). 
Providing a _salt_ value is highly recommended as it prevents pre-computation, and more importantly different salts generate different keys for the same password.

{{<mermaid align="left">}}
graph LR;
    P(Password) --> PBKDF["fa:fa-cog Password Based Key Derivation Function (PBKDF)"]
    S(Salt) -. recommended .-> PBKDF
    PBKDF --> K(fa:fa-key Key)
    PBKDF --> nonce("fa:fa-key Nonce/IV")
    nonce -.-> AES[fa:fa-cog AES]
    K -.-> AES

    classDef dotted_border stroke-width:2,stroke-dasharray:2,4;
    class AES,S dotted_border
{{< /mermaid >}}

If you already have a cryptographically strong key it can be used to _derive_ more keys from it. These keys are often called _data protection keys_ because they are used to protect a single data item.

TODO: Add [NIST Special Publication 800-38D](https://csrc.nist.gov/publications/detail/sp/800-38d/final)

{{<mermaid align="left">}}
graph LR;
    Context(Context) --> KeyID
    SubkeyID(Subkey ID) --> KeyID
    Version(Data version) --> KeyID

    MK(fa:fa-key  Masterkey) --> KDF[fa:fa-cog Key Derivation Function]
    KeyID(Key identifier) --> KDF
    S(Salt) -. optional .-> KDF
    
    KDF --> nonce(fa:fa-key Nonce)
    KDF --> SK(fa:fa-key Subkey)
    
    SK -.-> AES[fa:fa-cog AES]
    nonce -.-> AES

    classDef dotted_border stroke-width:2,stroke-dasharray:2,4;
    class AES,S dotted_border
{{< /mermaid >}}

* Keys can be derived from passwords with [password based key derivation functions](passwords/).
* Key  can be derived from other keys with [key derivation functions](kdf/).


## Details
{{% children description="true" depth="1"  %}}

## Further Reading
* [Key stretching](https://en.wikipedia.org/wiki/Key_stretching) on Wikipedia.
* [NIST Special Publication 800-132: Recommendation for Password-Based Key Derivation](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf)
* [NIST Special Publication 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf)
* [Key derivation function](https://en.wikipedia.org/wiki/Key_derivation_function) on Wikipedia.
