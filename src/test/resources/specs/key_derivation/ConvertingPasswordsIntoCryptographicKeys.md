# Converting a (master) password into a cryptographic key

Most systems use passwords to create (derive) cryptographic keys, e.g. the password to decrypt a ZIP file or the GPG passphrase are used to create a cryptographic key.

The process of creating a cryptographic key from a password is called _password based key derivation_. Because passwords are often to short/predictable this derivation often also implements some kind of _key strengthening_ or _key stretching_ (see below for more info).

To properly derive a key from a passwords a few aspects are important to consider. 

## TL;RD: Recommendation
* Use long and complex passwords as key source (128 bit key => 22 characters, 256 bit keys => 44 characters!)
* Use a random salt value that is as long as the key (128 or 256 bits)
* Configure the key stretching to be as slow (sic!) as possible 


### Usage with Bouncy-GPG

Cryptographic key derivation functions should be used to derive a key from a password (or _any_ other source material).
Bouncy-GPG uses [SCrypt](https://en.wikipedia.org/wiki/Scrypt)  for key stretching.

For example the following snippet will derive a 256 bit key from a strong password. The derivation process is configured
by `SCryptKeyStretchingParameters.forStrongInputKeyMaterial()`. This will give a very quick key derivation and is only
secure because the password is very long and random. If a shorter password was used the recommendation would be to use:

    ```groovy result:#generatedKey
    import java.nio.charset.StandardCharsets;
    
    import org.bouncycastle.util.encoders.Hex;
    
    import name.neuhalfen.projects.crypto.symmetric.keygeneration.impl.stretching.KeyStretching;
    import name.neuhalfen.projects.crypto.symmetric.keygeneration.impl.stretching.SCryptKeyStretching;
    
    // the password
    String password = "39akldsAFQqwmsx-+#aQcsvcu82cQd,.-ask72=cq8csf";
    
    // The salt value should be application or installation specific.
    // It is an absolute MUST that the salt is never changed! A different salt WILL result in a different
    // key being generated!
    // The salt value SHOULD be roughly as long as the key (e.g. 128/256 bit).
    // The salt value SHOULD be random (so this salt value is actually a bad example)
    final byte[] SALT = Hex.decode("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f");
    
    // In this case we are using a 256 bit key, e.g. for AES-128.
    final int DESIRED_KEY_LENGTH = 256;
     
    // Use forSensitiveStorage to derive e.g. a masterkey at application startup.
    // forSensitiveStorage is really slow. If you are very sure that you have a very
    // good (22 characters random or longer) password for 128 bit keys / 44 character 
    // passwords for 256 bit keys you can consider using forQuickDerivation.
    final SCryptKeyStretching.SCryptKeyStretchingParameters stretchingParameters = SCryptKeyStretching.SCryptKeyStretchingParameters.forStrongInputKeyMaterial();
    final KeyStretching streching = new SCryptKeyStretching(stretchingParameters);
    
    byte[] key = streching.strengthenKey(SALT, password.getBytes(StandardCharsets.UTF_8), DESIRED_KEY_LENGTH);
    return key;
    ```
    
The key generated by this sequence is [0x89d4a9b23d8a88d09e559aeeaa7cfa4a029673b01d969a2f523a7c1f749c330b](- "?=toHex(#generatedKey)").

# Requirements for key derivation

For those interested in learning a bit of background about key derivation the following paragraphs give a very short overview of the basic requirements of key derivation (from a password).

### Deterministic

The process of key derivation has to be [deterministic](https://en.wikipedia.org/wiki/Deterministic_system). That is, given the same input parameters (password and other parameters of the _derivation function_) the generated key is always the same.

#### [Example](- "Key derivation is deterministic")
E.g. the password _[s3cret](- "#password")_ (which is _way_ to short!) might be [derived](- "#key = stretchWithFixedParameters(#password)") to the key [0x81d0994d0aa21b786d6b8dc45fc09f31](- "?=#key.derivedKey").

[Calling](- "#key2 = stretchWithFixedParameters(#password)") the derivation function with the same parameters again yields the same result ([0x81d0994d0aa21b786d6b8dc45fc09f31](- "?=#key2.derivedKey")).

Using the same password with different configuration parameters for the same password (e.g. with a different [salt](https://en.wikipedia.org/wiki/Salt_%28cryptography%29) value) [yields a different key](- "c:assert-true=isSaltChangesKey(#password)").

### Password length
Cryptographically strong passwords are remarkably difficult to use because they are really, really long.
For the sake of discussion assume a password with the allowed symbols `a-z + A-Z + 0-9`. That are 62 different symbols per character. This is a bit less than ~6 bit per character.

A cryptographic key typically has a length of 128 or 256 completely random bits. E.g. a secure 128 bit key would require a completely random password of 22 characters (precisely `128 / log_2(62)` [*]). Sometimes this cannot be ensured, for example when the password is a users login password.

To derive keys from passwords two length-related problems need to be solved:

1. Squash arbitrary long passwords into 128 / 256 bit keys
2. Prevent attackers from enumerating (to short) passwords

[*] _Rule of thumb: `c` possible symbols are `log_2(c)` bits per character. `n` characters are then `n * log_2(c)` bits.  If your calculator does not have `log_2` use `log(c)/log(2)`_

#### [Example: Key length is independent from password length](- "Key length is independent from password length")

The length of the derived key is independent from the length of the password [1]:

| [derive][][Password][password]  | [Desired key length in bit][desiredKeyLen]  | [derived key][derivedKey]                                             | [length of derived key][derivedKeyLen] |
|---------------------------------|---------------------------------------------|-----------------------------------------------------------------------|-----------------------|
| x                               | 128                                         | 0xec8bf237a7207690e91cf6bd27746f3b                                    | 128                   |
| short password                  | 128                                         | 0x185e58c7cf69baef9d2866b70ec1581c                                    | 128                   |
| short password                  | 256                                         | 0x185e58c7cf69baef9d2866b70ec1581ceb8ff7c5c2169170cba1cf4adc48815a    | 256                   |
| a bit longer PASSWORD           | 128                                         | 0xb201445d3bcdc7a07c469b7d7ef8988c                                    | 128                   |

[password]: - "#password"
[desiredKeyLen]: - "#desiredKeyLen"
[derive]: - "#key = stretchWithFixedParameters(#password, #desiredKeyLen)"
[derivedKey]: - "?=#key.derivedKey"
[derivedKeyLen]: - "?=#key.derivedKeyLen"

[1] Salt and all other derivation parameters fixed for this run. Changing the salt or the parameters of the derivation function does not change the key length.

#### [Example: Prevent pre-computation with salt](- "Prevent pre-computation with salt")

Especially for short passwords it is desirable to prevent attackers from pre-computing (e.g. with [Rainbow tables](https://en.wikipedia.org/wiki/Rainbow_table))
all possible keys upfront.

There are two strategies to achieve this.

First the calculation can include an additional parameter that makes key derivation specific to an application/installation.
This raises the bar for the attacker because the pre-computation for one application cannot be used for a second application.
Such a value is called a [salt](https://en.wikipedia.org/wiki/Salt_%28cryptography%29) and can be public.

Secondly, computation can be made very expensive, so that an attacker would need to spend to much time to compute all possible keys.
This approach is implemented by functions such as  [SCrypt](https://en.wikipedia.org/wiki/Scrypt) or [PBKDF2](https://tools.ietf.org/html/rfc2898).
Slowing down computations is especially important for cases where the attacker has access to the database with the password hashes (and the salt). This is not unlikely because databases are stolen quite frequently.
Brute force protection makes key generation much slower, thus hampering an attacker to just try out every possible user password to "brute force" the key.


| [stretchWithSalt][][Password][password]  | [Salt][salt]              | [derived key][derivedKey]             |
|---------------------------------|------------------------------------|---------------------------------------|
| a bit longer PASSWORD           | 0x00                               | 0x62109f2b71882325eb62fb2d4dae3ef2    |
| short password                  | 0x00                               | 0xa8182f30638baea8c1b6991dd8f71070    |
| short password                  | 0x01                               | 0x185e58c7cf69baef9d2866b70ec1581c    |
| short password                  | 0x0123456789abcdef0123456789abcdef | 0x89b4d1be23e0f1f56ba29ee36f1e52ba    |

[password]: - "#password"
[salt]: - "#salt"
[stretchWithSalt]: - "#key = stretchWithSalt(#password, #salt)"
[derivedKey]: - "?=#key.derivedKey"

### Unwanted structure / lacking entropy

Besides the length of the password, it also has a lot of inherent structure (e.g. the mentioned 62 symbols all have the most significant bit set to zero). This structure needs to be "smoothed out" before using the password das key material.


### Further Reading
* [Key stretching](https://en.wikipedia.org/wiki/Key_stretching) on Wikipedia.
* [NIST Special Publication 800-132: Recommendation for Password-Based Key Derivation](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf)
* [Key derivation function](https://en.wikipedia.org/wiki/Key_derivation_function) on Wikipedia.
