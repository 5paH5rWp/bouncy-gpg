[
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/categories/api/",
	"title": "Api",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/",
	"title": "Bouncy GPG",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/key_derivation/convertingpasswordsintocryptographickeys/",
	"title": "Converting a (master) password into a cryptographic key",
	"tags": ["specification", "development"],
	"description": "",
	"content": "Most systems use passwords to create (derive) cryptographic keys, e.g. the password to decrypt a ZIP file is used to create a cryptographic key.\nThe process of creating a cryptographic key from a password is called password based key derivation. Because passwords are often to short/predictable this derivation often also implements some kind of key strengthening or key stretching (see below for more info).\nTo properly derive a key from a passwords a few aspects are important to consider. TL;RD: RecommendationUse long and complex passwords as key source (128 bit key =\u0026gt; 22 characters, 256 bit keys =\u0026gt; 44 characters!)Use a random salt value that is as long as the key (128 or 256 bits)Configure the key stretching to be as slow (sic!) as possibleUsage with Bouncy-GPGCryptographic key derivation functions should be used to derive a key from a password (or any other source material). Bouncy-GPG uses SCrypt for key stretching.\nThe following snippet will derive a 256 bit key from a strong password. The derivation process is configured by SCryptKeyStretchingParameters.forStrongInputKeyMaterial(). This will give a very quick key derivation and is only secure because the password is very long and random. If a shorter password was used the recommendation would be to use:\nimport java.nio.charset.StandardCharsets; import org.bouncycastle.util.encoders.Hex; import name.neuhalfen.projects.crypto.symmetric.keygeneration.impl.stretching.KeyStretching; import name.neuhalfen.projects.crypto.symmetric.keygeneration.impl.stretching.SCryptKeyStretching; // the password String password = \"39akldsAFQqwmsx-+#aQcsvcu82cQd,.-ask72=cq8csf\"; // The salt value should be application or installation specific. // It is an absolute MUST that the salt is never changed! A different salt WILL result in a different // key being generated! // The salt value SHOULD be roughly as long as the key (e.g. 128/256 bit). // The salt value SHOULD be random (so this salt value is actually a bad example) final byte[] SALT = Hex.decode(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"); // In this case we are using a 256 bit key, e.g. for AES-128. final int DESIRED_KEY_LENGTH = 256; // Use forSensitiveStorage to derive e.g. a masterkey at application startup. // forSensitiveStorage is really slow. If you are very sure that you have a very // good (22 characters random or longer) password for 128 bit keys / 44 character // passwords for 256 bit keys you can consider using forQuickDerivation. final SCryptKeyStretching.SCryptKeyStretchingParameters stretchingParameters = SCryptKeyStretching.SCryptKeyStretchingParameters.forStrongInputKeyMaterial(); final KeyStretching streching = new SCryptKeyStretching(stretchingParameters); byte[] key = streching.strengthenKey(SALT, password.getBytes(StandardCharsets.UTF_8), DESIRED_KEY_LENGTH); return key;The key generated by this sequence is 0x89d4a9b23d8a88d09e559aeeaa7cfa4a029673b01d969a2f523a7c1f749c330b.\nRequirements for key derivationFor those interested in learning a bit of background about key derivation the following paragraphs give a very short overview of the basic requirements of key derivation (from a password).\nThese are not all requirements for key derivation functions. The requirements shown here shed some light on key derivation functions from an API user perspective.\nDeterministicThe process of key derivation has to be deterministic. That is, given the same input parameters (password and other parameters of the derivation function) the generated key is always the same.\nExampleE.g. the password s3cret (which is way to short!) might be derived to the key 0x81d0994d0aa21b786d6b8dc45fc09f31.\nCalling the derivation function with the same parameters again yields the same result (0x81d0994d0aa21b786d6b8dc45fc09f31).\nUsing the same password with different configuration parameters for the same password (e.g. with a different salt value) yields a different key.\nPassword lengthCryptographically strong passwords are remarkably difficult to use because they are really, really long. For the sake of discussion assume a password with the allowed symbols a-z + A-Z + 0-9. That are 62 different symbols per character. This is a bit less than ~6 bit per character.\nA cryptographic key typically has a length of 128 or 256 completely random bits. E.g. a secure 128 bit key would require a completely random password of 22 characters (precisely 128 / log_2(62) [*]). Sometimes this cannot be ensured, for example when the password is a users login password.\nTo derive keys from passwords two length-related problems need to be solved:\nSquash arbitrary long passwords into 128 / 256 bit keysPrevent attackers from enumerating (to short) passwords[*] Rule of thumb: c possible symbols are log_2(c) bits per character. n characters are then n * log_2(c) bits. If your calculator does not have log_2 use num_bits ~= n * 3.3 * log_10(c)\nExample: Key length is independent from password lengthThe length of the derived key is independent from the length of the password [1]:\nPassword Desired key length in bit derived key length of derived key x 128 0xec8bf237a7207690e91cf6bd27746f3b 128 short password 128 0x185e58c7cf69baef9d2866b70ec1581c 128 short password 256 0x185e58c7cf69baef9d2866b70ec1581ceb8ff7c5c2169170cba1cf4adc48815a 256 a bit longer PASSWORD 128 0xb201445d3bcdc7a07c469b7d7ef8988c 128 [1] Salt and all other derivation parameters fixed for this run. Changing the salt or the parameters of the derivation function does not change the key length.\nExample: Prevent pre-computation with saltEspecially for short passwords it is desirable to prevent attackers from pre-computing (e.g. with Rainbow tables) all possible keys upfront.\nThere are two strategies to achieve this.\nFirst the calculation can include an additional parameter that makes key derivation specific to an application/installation. This raises the bar for the attacker because the pre-computation for one application cannot be used for a second application. Such a value is called a salt and can be public.\nSecondly, computation can be made very expensive, so that an attacker would need to spend to much time to compute all possible keys. This approach is implemented by functions such as SCrypt or PBKDF2. Slowing down computations is especially important for cases where the attacker has access to the database with the password hashes (and the salt). This is not unlikely because databases are stolen quite frequently. Brute force protection makes key generation much slower, thus hampering an attacker to just try out every possible user password to \"brute force\" the key.\nChanging the salt value will derive different keys from the same password (thus making precomputing infeasible):\nPassword Salt derived key a bit longer PASSWORD 0x00 0x62109f2b71882325eb62fb2d4dae3ef2 short password 0x00 0xa8182f30638baea8c1b6991dd8f71070 short password 0x01 0x185e58c7cf69baef9d2866b70ec1581c short password 0x0123456789abcdef0123456789abcdef 0x89b4d1be23e0f1f56ba29ee36f1e52ba Unwanted structure / lacking entropyBesides the length of the password, it also has a lot of inherent structure (e.g. the mentioned 62 symbols all have the most significant bit set to zero). This structure needs to be \"smoothed out\" before using the password das key material.\nFurther ReadingKey stretching on Wikipedia.NIST Special Publication 800-132: Recommendation for Password-Based Key DerivationKey derivation function on Wikipedia.Results generated by Concordionin 1099 ms on 19-Aug-2017 at 00:09:29 CEST"
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/key_derivation/",
	"title": "Key_derivations",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/specification/",
	"title": "Specification",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]