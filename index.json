[
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/about/",
	"title": "About Bouncy GPG",
	"tags": [],
	"description": "",
	"content": "Bouncy GPG is a java library that provides an opinionated API for cryptographic use cases. It also strives to provide the best documentation for programmers to solve problems without shooting theirselves in the foot.\nBouncy GPG is licensed under the very permissive .\nLearn more and contribute on GitHub.\nThe website is generated with hugo and the beautiful docdock theme.\nAll code samples are actually executed at build time by concordion and the concordion-api-documentation-extension.\nPull requests welcome!\n"
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Bouncy GPG       \nMission Statement Make using Bouncy Castle with OpenPGP great fun again!\nThis project gives you the following super-powers\n encrypt, decrypt, sign and verify GPG/PGP files with just a few lines of code protect all the data at rest by reading encrypted files with transparent GPG decryption you can even decrypt a gpg encrypted ZIP and re-encrypt each file in it again \u0026ndash; never again let plaintext hit your servers disk!  Examples Bouncy GPG comes with several examples build in.\nKey management Bouncy GPG supports reading gpg keyrings and parsing keys exported via gpg --export and gpg --export-secret-key.\nThe unit tests have some examples creating/reading keyrings.\nThe easiest way to manage keyrings is to use the pre-defined KeyringConfigs.\nEncrypting a file The following snippet encrypts /tmp/plaintext.txt to recipient@example.com and signs with sender@example.com. The encrypted file is written to /tmp/encrypted.gpg.\nfinal KeyringConfig keyringConfig = KeyringConfigs .withKeyRingsFromFiles( \u0026quot;pubring.gpg\u0026quot;, \u0026quot;secring.gpg\u0026quot;, KeyringConfigCallbacks.withPassword(\u0026quot;s3cr3t\u0026quot;)); try ( final FileOutputStream fileOutput = new FileOutputStream(\u0026quot;/tmp/encrypted.gpg\u0026quot;); final BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOutput); final OutputStream outputStream = BouncyGPG .encryptToStream() .withConfig(keyringConfig) .withStrongAlgorithms() .toRecipient(\u0026quot;recipient@example.com\u0026quot;) .andSignWith(\u0026quot;sender@example.com\u0026quot;) .binaryOutput() .andWriteTo(bufferedOut); final FileInputStream is = new FileInputStream(\u0026quot;/tmp/plaintext.txt\u0026quot;) ) { Streams.pipeAll(is, outputStream); }  Decrypting a file and validating the signature The following snippet decrypts the file created in the snippet above.\nfinal KeyringConfig keyringConfig = KeyringConfigs .withKeyRingsFromFiles( \u0026quot;pubring.gpg\u0026quot;, \u0026quot;secring.gpg\u0026quot;, KeyringConfigCallbacks.withPassword(\u0026quot;s3cr3t\u0026quot;)); try ( final FileInputStream cipherTextStream = new FileInputStream(\u0026quot;/tmp/encrypted.gpg\u0026quot;); final FileOutputStream fileOutput = new FileOutputStream(destFile); final BufferedOutputStream bufferedOut = new BufferedOutputStream(fileOutput); final InputStream plaintextStream = BouncyGPG .decryptAndVerifyStream() .withConfig(keyringConfig) .andIgnoreSignatures() .fromEncryptedInputStream(cipherTextStream) ) { Streams.pipeAll(plaintextStream, bufferedOut); }  Performance Bouncy castle is often fast enough to not be the bottleneck. That said, here are some metrics to give you an indication of the performance:\n   Use Case MBP 2,9 GHz Intel Core i5, Java 1.8.0_111 (please add more via PR)     Encrypt \u0026amp; sign 1GB random ~64s (16 MB/s)    Decrypt 1GB random ~32s (32 MB/s)     Demos The directory examples contains several examples that show how easy some common use cases are implemented.\ndemo_decrypt.sh Decrypt a file and verify the signature.\n decrypt.sh SOURCEFILE DESTFILE  Uses the testing keys to decrypt a file. Useful for performance measurements and gpg interoperability.\ndemo_encrypt.sh Encrypt and sign a file.\n encrypt.sh SOURCEFILE DESTFILE  Uses the testing keys to encrypt a file. Useful for performance measurements and gpg interoperability.\ndemo_reencrypt.sh A GPG encrypted ZIP file is decrypted on the fly. The structure of the ZIP is then written to disk. All files are re-encrypted before saving them.\n demo_reencrypt.sh TARGET \u0026ndash; decrypts an encrypted ZIP file containing three files (total size: 1.2 GB) AND re-encrypts each of the files in the ZIP to the TARGET dir.  The sample shows how e.g. batch jobs can work with large files without leaving plaintext on disk (together with Transparent GPG decryption).\nThis scheme has some very appealing benefits: * Data in transit is always encrypted with public key cryptography. Indispensable when you have to use ftp, comforting when you use https and the next Heartbleed pops up. * Data at rest is always encrypted with public key cryptography. When (not if) you get hacked, this can make all the difference between \u0026ldquo;Move along folks, nothing to see here!\u0026rdquo; and \u0026ldquo;I lost confidential customer data to the competition\u0026rdquo;. * You still need to protect the private keys, but this is considerable easier than the alternatives.\nConsider the following batch job:\n The customer sends a large (several GB) GPG encrypted ZIP archive containing a directory structure with several data files Your pre-processing needs to split up the data for further processing pre-processing stream-processes the GPG/ZIP archive  The GPG stream is decrypted using the BouncyGPG.decryptAndVerifyStream() InputStream The ZIP file is processed with ExplodeAndReencrypt  Each file from the archive is processed And transparently encrypted with GPG and stored for further processing   The processing job transparently reads the files without writing plaintext to the disk.  HOWTO Have a look at the example classes to see how easy it is to use Bouncy Castle PGP.\n#1 Bouncy Castle Provider Dependency Add bouncy castle as a dependency and then install the provider before in your application.\nAdd Build Dependency Gradle // build.gradle // in build.gradle add a dependency to bouncy castle and bouncy-gpg //... repositories { mavenCentral() jcenter() } //... // ... dependencies { compile 'org.bouncycastle:bcprov-jdk15on:1.57' compile 'org.bouncycastle:bcpg-jdk15on:1.57' // ... compile 'name.neuhalfen.projects.crypto.bouncycastle.openpgp:bouncy-gpg:2.+' // ... }  Maven Dropping this in the root level of pom.xml lets you use this lib in a maven project:\n\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;bintray\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;bintray\u0026lt;/name\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;url\u0026gt;http://jcenter.bintray.com\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt;  and this dependency snippet:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;name.neuhalfen.projects.crypto.bouncycastle.openpgp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bouncy-gpg\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Â #2 Install Provider // in one of you classed install the BC provider if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) { Security.addProvider(new BouncyCastleProvider()); }  Important Classes    Class Use when you want to     BouncyGPG Starting point for the convenient fluent en- and decryption API.   KeyringConfigs Create default implementations for GPG keyring access. You can also create your own implementations by implementing KeyringConfig.   KeyringConfigCallbacks Used by KeyringConfigs. Create default implementations to provide secret-key passwords.   DefaultPGPAlgorithmSuites Select from predefined algorithms suites or create your won with PGPAlgorithmSuite.   ReencryptExplodedZipSinglethread Work with encrypted ZIPs    FAQ  Why should I use this? For common use cases this project is easier than vanilla Bouncy Castle. It also has a pretty decent unit test coverage. It is free (speech \u0026 beer). Can I just grab a class or two for my project? Sure! Just grab it and hack away! The code is placed under the Apache License 2.0, you can't get much more permissive than this. Why is the test coverage so low? Test coverage for 'non-example' code is \u0026gt;85%. Most of the not tested cases are either trivial OR lines that throw exceptions when the input format is broken.  How can I contribute? Pullrequests are welcome! Please state in your PR that you put your code under the LICENSE. I am getting 'org.bouncycastle.openpgp.PGPException: checksum mismatch ..' exceptions The passphrase to your private key is very likely wrong (or you did not pass a passphrase). I am getting 'java.security.InvalidKeyException: Illegal key size' / 'java.lang.SecurityException: Unsupported keysize or algorithm parameters' The unrestricted policy files for the JVM are probably not installed. Where is 'secring.pgp'? 'secring.gpg' has been removed in gpg 2.1. Use the other methods to read private keys.  Building The project is a basic gradle build. All the scripts use ./gradlew installDist\nThe coverage report (incl. running tests) is generated with ./gradlew check.\nPublish to jcenter ./gradlew bintrayUpload\nWebsite  Preview: ./gradlew previewWebsite Publish: ./gradlew publishWebsite  All Concordion specifications are executed and the result is copied into website/content/specification.\nCAVE  GPG: Only one keyring per userid (\u0026ldquo;sender@example.com\u0026rdquo;) supported. GPG: Only one signing key per userid supported. TODOs  LICENSE This code is placed under the Apache License 2.0. Don\u0026rsquo;t forget to adhere to the BouncyCastle License (http://bouncycastle.org/license.html).\n"
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/howto/keys/kdf/",
	"title": "Derive more keys from a key",
	"tags": ["howto", "key derivation", "TODO"],
	"description": "For many use cases it is desirable to derive multiple keys from one master key. This not only increases security, it also greatly simplifies key management.",
	"content": " For many use cases it is desirable to derive multiple keys from one master key. This not only increases security, it also greatly simplifies key management.\ngraph LR; MK(fa:fa-key Masterkey) -- KDF[fa:fa-cog Key Derivation Function] S(Salt) -- KDF ID(Context + SubKey ID) -- KDF KDF -- SK(fa:fa-key Subkey) SK -.- AES[fa:fa-cog AES]  TODO\nExamples   Example: Deriving record specific keys  Deriving record specific keys with HKDF.\n "
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/example/",
	"title": "Example",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/howto/keys/passwords/example/convertingpasswordsintocryptographickeys/",
	"title": "Example: Converting a password into a cryptographic key",
	"tags": ["howto", "key derivation", "passwords", "example"],
	"description": "This example will derive a 256 bit AES key from passwords.",
	"content": "The following code snippets are actually compiled and run during the BouncyGPG build process. This ensures that all examples are correct.\nUsage with Bouncy-GPGCryptographic key derivation functions should be used to derive a key from a password (or any other source material). Bouncy-GPG uses SCrypt for key stretching.\nThe following snippet will derive a 256 bit key from a strong password. The derivation process is configured by SCryptKeyStretchingParameters.forStrongInputKeyMaterial(). This will give a very quick key derivation and is only secure because the password is very long and random. If a shorter password was used the recommendation would be to use forModeratelyStongInputKeyMaterial or forWeakInputKeyMaterial.\nimport java.nio.charset.StandardCharsets; import org.bouncycastle.util.encoders.Hex; import name.neuhalfen.projects.crypto.symmetric.keygeneration.impl.stretching.KeyStretching; import name.neuhalfen.projects.crypto.symmetric.keygeneration.impl.stretching.SCryptKeyStretching; // the password // Rather obviously the password should NOT be stored as part of the source code String password = \"39akldsAFQqwmsx-+#aQcsvcu82cQd,.-ask72=cq8csf\"; // The salt value should be application or installation specific. // It is an absolute MUST that the salt is never changed! A different salt WILL result in a different // key being generated! // The salt value SHOULD be roughly as long as the key (e.g. 128/256 bit). // The salt value SHOULD be random (so this salt value is actually a bad example) final byte[] SALT = Hex.decode(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"); // In this case we are using a 256 bit key, e.g. for AES-256. final int DESIRED_KEY_LENGTH = 256; // Use forSensitiveStorage to derive e.g. a masterkey at application startup. // forSensitiveStorage is really slow. If you are very sure that you have a very // good (22 characters random or longer) password for 128 bit keys / 44 character // passwords for 256 bit keys you can consider using forQuickDerivation. final SCryptKeyStretching.SCryptKeyStretchingParameters stretchingParameters = SCryptKeyStretching.SCryptKeyStretchingParameters.forStrongInputKeyMaterial(); final KeyStretching streching = new SCryptKeyStretching(stretchingParameters); byte[] key = streching.strengthenKey(SALT, password.getBytes(StandardCharsets.UTF_8), DESIRED_KEY_LENGTH); return key;The key generated by this sequence is 0x89d4a9b23d8a88d09e559aeeaa7cfa4a029673b01d969a2f523a7c1f749c330b.\nExampleThe password s3cret (which is way to short!) might be derived to the key 0x81d0994d0aa21b786d6b8dc45fc09f31.\nCalling the derivation function with the same parameters again yields the same result (0x81d0994d0aa21b786d6b8dc45fc09f31).\nUsing the same password with different configuration parameters for the same password (e.g. with a different salt value) yields a different key.\nExample: Key length is independent from password lengthThe length of the derived key is independent from the length of the password [1]:\nPassword Desired key length in bit derived key length of derived key x 128 0xec8bf237a7207690e91cf6bd27746f3b 128 short password 128 0x185e58c7cf69baef9d2866b70ec1581c 128 short password 256 0x185e58c7cf69baef9d2866b70ec1581ceb8ff7c5c2169170cba1cf4adc48815a 256 a bit longer PASSWORD 128 0xb201445d3bcdc7a07c469b7d7ef8988c 128 [1] Salt and all other derivation parameters fixed for this run. Changing the salt or the parameters of the derivation function does not change the key length.\nExample: Prevent pre-computation with saltChanging the salt value will derive different keys from the same password (thus making precomputing infeasible):\nPassword Salt derived key a bit longer PASSWORD 0x00000000000000000000000000000000 0x31709b5748dd11a80de4ba31571928d3 short password 0x00000000000000000000000000000000 0xefab7a10563f8d81347c8c4401553902 short password 0x00000000000000000000000000000001 0xc0c153c9b79a92af8bdb08cb5defbd11 short password 0x0123456789abcdef0123456789abcdef 0x89b4d1be23e0f1f56ba29ee36f1e52ba Results generated by Concordionin 382 ms on 30-Sep-2017 at 19:53:59 CEST"
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/howto/keys/kdf/example/derivingfromcryptographickeys/",
	"title": "Example: Deriving record specific keys",
	"tags": ["howto", "key derivation", "example"],
	"description": "Deriving record specific keys with HKDF.",
	"content": "The following code snippets are actually compiled and run during the BouncyGPG build process. This ensures that all examples are correct.\nTo derive another key from one (master key) a key derivation function should be used. HKDF defined in RFC5869 is such a function.\nInternally HKDF uses an HMAC to derive multiple keys fro one master key.\nTo quote from RFC5869:\nA key derivation function (KDF) is a basic and essential component of cryptographic systems. Its goal is to take some source of initial keying material and derive from it one or more cryptographically strong secret keys.\nThe following code will derive an AES-128 key and IV (or nonce) for a record identified as version 3 of row #2386221 in MY_TABLE:\nimport java.security.GeneralSecurityException; import name.neuhalfen.projects.crypto.symmetric.keygeneration.DerivedKeyGenerator; import name.neuhalfen.projects.crypto.symmetric.keygeneration.DerivedKeyGeneratorFactory; import org.bouncycastle.util.encoders.Hex; // Rather obviously the master key MUST NOT be part of the source code! // This is only for demonstration purposes! byte[] masterkey = Hex.decode(\"81d0994d0aa21b786d6b8dc45fc09f31\"); // The salt value should not be part of the source code. // The same salt value can be reused for all key derivations. byte[] salt = Hex.decode(\"b201445d3bcdc7a07c469b7d7ef8988c\"); // These settings depend on the algorithms used. // This combination could e.g. be used for AES-256 in CTR or CBC mode final int IV_LENGTH_BYTES = 128 / 8; // This is the length of the generated key. // For AES-256 use KEY_LENGTH_BYTES = 256/8 final int KEY_LENGTH_BYTES = 128 / 8; // The key to be generated depends on three things: // - the master key // - the salt value // - the info // Master key and salt are relatively static and are often scoped \"per installation of the application\". // // The info value must(!) uniquely(!) identify the object to be encrypted. // It is mandatory that the same key/iv combination is not used multiple times. // A good way to do this is to use a combination of the objects type, id, and version. // Version means: \"This is incremented every time the record is changed\". // Using a random value (that is refreshed for each update) is also possible. String context = \"MY_TABLE\"; String databasePrimaryKey = \"2386221\"; String recordVersion = \"3\"; final DerivedKeyGenerator derivedKeyGenerator = DerivedKeyGeneratorFactory .fromInputKey(masterkey) .andSalt(salt) .withHKDFsha256(); final byte[] iv = new byte[IV_LENGTH_BYTES]; final byte[] key = new byte[KEY_LENGTH_BYTES]; // The key derivation creates (arbitrary long) streams of \"randomness\" (it is a PRF - pseudo random function). // Request enough randomness to cover IV and key final byte[] keyAndIV = derivedKeyGenerator .deriveKey(context, databasePrimaryKey, recordVersion, IV_LENGTH_BYTES + KEY_LENGTH_BYTES); System.arraycopy(keyAndIV, 0, key, 0, key.length); System.arraycopy(keyAndIV, key.length, iv, 0, iv.length); System.out.println(\"IV: \" + Hex.toHexString(iv)); System.out.println(\"Key: \" + Hex.toHexString(key));IV: 3af706a49e4d9bb09cbdb01bbfc9d8ff Key: 551cb7df244e577b5b556634117c3895 Example: Changing the version will change the derived keyChanging the version of the record value will derive different keys. The IV for this example is not shown. Also the key length is set to 128 bit.\nThe Context ID Version derived key Remark MY_TABLE 2386221 1 0xec82fb52017238960175d3a67d8f8f97 This and the following two rows show keys for multiple versions of the same record. MY_TABLE 2386221 2 0xe1ba165e7796a4eae010ba90831d00c5 Incrementing the version field will generate different keys. MY_TABLE 2386221 3 0x551cb7df244e577b5b556634117c3895 The example shown above CarInsuranceContract 2386221 3 0x8cf4a7e699f51ad9fa01598898f02052 The same 'row' in different 'tables' yields different keys CarInsuranceContract D9FF7A8A-5692-48D7-A4F7-45E149448BBA 9EBDF712-BBBE-480E-8369-A79F8E653B63 0x7eed3ff1996d95db97eefcbd55f2d8d3 Versions just need to be distinct, not necessarily integers CarInsuranceContract D9FF7A8A-5692-48D7-A4F7-45E149448BBA 570E7AA2-EC6A-4F14-A58E-BB3E7E671FED 0x2e7bc71432f52b1a868553de401c4f84 Results generated by Concordionin 1444 ms on 30-Sep-2017 at 19:53:59 CEST"
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/howto/keys/passwords/",
	"title": "From password to key",
	"tags": ["howto", "key derivation", "passwords"],
	"description": "The process of deriving  a cryptographic key from a password is called password based key derivation. Because passwords are often to short/predictable this derivation often also implements some kind of key strengthening or key stretching.",
	"content": " The words password and cryptographic key are often used interchangeably, although they are technically very different. Most systems use passwords to derive cryptographic keys, e.g. the password entered to decrypt a ZIP file is used to derive a cryptographic key, which then is used to en-/decrypt the ZIP file.\nThe process of deriving a cryptographic key from a password is called password based key derivation. Because passwords are often to short/predictable this derivation often also implements some kind of key strengthening or key stretching (see below for more info).\ngraph LR; P(Password) -- PBKDF[fa:fa-cog Password based Key Derivation Function] S(Salt) -- PBKDF PBKDF -- K(fa:fa-key Key) K -.- AES[fa:fa-cog AES]  To properly derive a key from a passwords a few aspects are important to consider.\nTL;RD: Recommendation Recommendation:\n Always use a key derivation function. Never use input key material without a key derivation function. Use long and complex passwords as key source (128 bit key =\u0026gt; 22 characters, 256 bit keys =\u0026gt; 44 characters!) Use a random salt value that is as long as the key (128 or 256 bits) Configure the key stretching to be as slow (sic!) as possible    Cryptographic key derivation functions should be used to derive a key from a password (or any other source material). Bouncy-GPG uses SCrypt for key stretching.\nRequirements for key derivation For those interested in learning a bit of background about key derivation the following paragraphs give a very short overview of the basic requirements of key derivation (from a password).\nThese are not all requirements for key derivation functions. The requirements shown here shed some light on key derivation functions from an API user perspective.\nDeterministic The process of key derivation has to be deterministic. That is, given the same input parameters (password and other parameters of the derivation function) the generated key is always the same.\nPassword length Cryptographically strong passwords are remarkably difficult to use because they are really, really long. For the sake of discussion assume a password with the allowed symbols a-z + A-Z + 0-9. That are 62 different symbols per character. This is a bit less than ~6 bit per character.\nA cryptographic key typically has a length of 128 or 256 completely random bits. E.g. a secure 128 bit key would require a completely random password of 22 characters (precisely 128 / log_2(62) [*]). Sometimes this cannot be ensured, for example when the password is a users login password.\nTo derive keys from passwords two length-related problems need to be solved:\n Squash arbitrary long passwords into 128 / 256 bit keys Prevent attackers from enumerating (to short) passwords  [*] Rule of thumb: c possible symbols are log_2(c) bits per character. n characters are then n * log_2(c) bits. If your calculator does not have log_2 use num_bits ~= n * 3.3 * log_10(c)\nPrevent pre-computation with salt Especially for short passwords it is desirable to prevent attackers from pre-computing (e.g. with Rainbow tables) all possible keys upfront.\nThere are two strategies to achieve this.\nFirst the calculation can include an additional parameter that makes key derivation specific to an application/installation. This raises the bar for the attacker because the pre-computation for one application cannot be used for a second application. Such a value is called a salt and can be public.\nAdding a salt value often is not enough. Even with consumer hardware simple hashes like SHA-1 or SHA-256 can be calculated at rates of mega hashes per second.\nSecondly, computation can be made very expensive, so that an attacker would need to spend to much time to compute all possible keys. This approach is implemented by functions such as SCrypt or PBKDF2. Slowing down computations is especially important for cases where the attacker has access to the database with the password hashes (and the salt). This is not unlikely because databases are stolen quite frequently. Brute force protection makes key generation much slower, thus hampering an attacker to just try out every possible user password to \u0026ldquo;brute force\u0026rdquo; the key.\nChanging the salt value will derive different keys from the same password (thus making precomputing infeasible).\nUnwanted structure / lacking entropy Besides the length of the password, it also has a lot of inherent structure (e.g. the mentioned 62 symbols all have the most significant bit set to zero). This structure needs to be \u0026ldquo;smoothed out\u0026rdquo; before using the password das key material.\nExamples  Example: Converting a password into a cryptographic key  This example will derive a 256 bit AES key from passwords.\n Further Reading  Key stretching on Wikipedia. NIST Special Publication 800-132: Recommendation for Password-Based Key Derivation Key derivation function on Wikipedia.  "
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/howto/",
	"title": "HowTo",
	"tags": [],
	"description": "",
	"content": " Even with a library like BouncyGPG it is impossible to correctly use the cryptography toolbox without a bit of theoretical background. The HOWTOs will give solid implementation guidelines regarding selected use cases.\nThe provide example code can act as starting point for your implementations.\nReading the use cases will provide you with enough information to implement them for \u0026ldquo;normal security\u0026rdquo; applications. For high security applications, e.g. when the life of people is at stake involve a cryptographer!\n Use Cases  Key generation and derivation  Cryptographic keys are the input parameters to many cryptographic operations, namely en-/decryption and signatures. This HOWTO will show you how to create keys from passwords, and how to derive multiple keys from one master key.\n "
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/howto/",
	"title": "Howto",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/key-derivation/",
	"title": "Key Derivation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/howto/keys/",
	"title": "Key generation and derivation",
	"tags": ["howto", "key derivation"],
	"description": "Cryptographic keys are the input parameters to many cryptographic operations, namely en-/decryption and signatures. This HOWTO will show you how to create keys from passwords, and how to derive multiple keys from one master key.",
	"content": " Cryptographic keys are the input parameters to many cryptographic operations, namely en-/decryption and signatures. This HOWTO will show you how to create keys from passwords, and how to derive multiple keys from one master key.\nCryptographic keys can be obtained by two methods:\n by generating a key from random data (e.g. SecureRandom) by deriving the key from other data (input key material)  Key Generation Cryptographic keys can be generated by using a random number generator (RNG). Cryptographic keys should always be generated by using a key derivation function.\ngraph LR; RNG(fa:fa-cog RNG) -- KDF[fa:fa-cog Key Derivation Function] KDF -- K(fa:fa-key Key) K -.- AES[fa:fa-cog AES]  Key Derivation The words password and cryptographic key are often used interchangeably, although they are technically quite different.\nA password is a sequence of characters of often arbitrary length. A cryptographic key is a binary object that has an algorithm specific structure to it.\ngraph LR; P(Password) -- PBKDF[fa:fa-cog Password based Key Derivation Function] S(Salt) -- PBKDF PBKDF -- K(fa:fa-key Key) K -.- AES[fa:fa-cog AES]  graph LR; MK(fa:fa-key Masterkey) -- KDF[fa:fa-cog Key Derivation Function] S(Salt) -- KDF ID(Context + SubKey ID) -- KDF KDF -- SK(fa:fa-key Subkey) SK -.- AES[fa:fa-cog AES]   Keys can be derived from passwords with password based key derivation functions. Key can be derived from other keys with key derivation functions.  Details  Derive more keys from a key  For many use cases it is desirable to derive multiple keys from one master key. This not only increases security, it also greatly simplifies key management.\n From password to key  The process of deriving a cryptographic key from a password is called password based key derivation. Because passwords are often to short/predictable this derivation often also implements some kind of key strengthening or key stretching.\n Further Reading  Key stretching on Wikipedia. NIST Special Publication 800-132: Recommendation for Password-Based Key Derivation Key derivation function on Wikipedia.  "
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/categories/keys/",
	"title": "Keys",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/passwords/",
	"title": "Passwords",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/tags/todo/",
	"title": "Todo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://neuhalje.github.io/bouncy-gpg/_header/",
	"title": "header",
	"tags": [],
	"description": "",
	"content": "Bouncy GPG Documentation\n"
}]